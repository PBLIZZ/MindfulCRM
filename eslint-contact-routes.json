[{"filePath":"/Users/peterjamesblizzard/projects/MindfulCRM/server/routes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_error' is defined but never used.","line":431,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":431,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":572,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":572,"endColumn":21},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":655,"column":63,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":655,"endColumn":65,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[21642,21644],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":751,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":751,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":760,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":760,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":761,"column":42,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":761,"endColumn":56},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .map on an `any` value.","line":761,"column":53,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":761,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":771,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":771,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":790,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":790,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":807,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":810,"endColumn":10},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .timestamp on an `any` value.","line":809,"column":40,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":809,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'user' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":832,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":832,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":872,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":872,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":881,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":881,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":894,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":894,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":897,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":897,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":925,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":940,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":940,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":940,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31446,31449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31446,31449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":945,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":945,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":983,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":983,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1015,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1015,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1052,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1052,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1055,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1055,"endColumn":19},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1092,"column":20,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1092,"endColumn":22,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[36942,36944],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1129,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1129,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1140,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1140,"endColumn":60},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1204,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":1204,"endColumn":32},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1218,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1218,"endColumn":66},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'usageStats' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1234,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":1234,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1285,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1285,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1349,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1349,"endColumn":56},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1351,"column":20,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1351,"endColumn":22,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[46541,46543],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":1352,"column":26,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":1352,"endColumn":28,"suggestions":[{"messageId":"suggestNullish","data":{"equals":""},"fix":{"range":[46572,46574],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1385,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":1385,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1403,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":1403,"endColumn":21},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1416,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1416,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1423,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":1423,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1442,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":1442,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1453,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1453,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1460,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1460,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1461,"column":38,"nodeType":"Property","messageId":"anyAssignment","endLine":1461,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1461,"column":44,"nodeType":"Property","messageId":"anyAssignment","endLine":1461,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":1463,"column":12,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1463,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .trim on an `any` value.","line":1463,"column":18,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1463,"endColumn":22},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1468,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":1468,"endColumn":26},{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of a(n) `any` typed value.","line":1468,"column":15,"nodeType":"MemberExpression","messageId":"unsafeCall","endLine":1468,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-member-access","severity":2,"message":"Unsafe member access .trim on an `any` value.","line":1468,"column":20,"nodeType":"Identifier","messageId":"unsafeMemberExpression","endLine":1468,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1469,"column":9,"nodeType":"Property","messageId":"anyAssignment","endLine":1469,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1488,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1488,"endColumn":64},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1490,"column":11,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1490,"endColumn":29},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1495,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":1495,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1496,"column":11,"nodeType":"Property","messageId":"anyAssignment","endLine":1496,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1506,"column":46,"nodeType":"Property","messageId":"anyAssignment","endLine":1506,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1515,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1515,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":1518,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":1518,"endColumn":19},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":1546,"column":13,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":1546,"endColumn":59}],"suppressedMessages":[],"errorCount":56,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport type { Request, Response } from 'express';\nimport { createServer, type Server } from 'http';\nimport { isAuthenticatedUser, type AuthenticatedUser } from './utils/type-guards.js';\nimport { logError, createErrorResponse } from './utils/error-handling.js';\n\n// Extend Express Request interface to include user property\ndeclare module 'express-serve-static-core' {\n  interface Request {\n    user?: AuthenticatedUser;\n  }\n}\nimport cookieParser from 'cookie-parser';\nimport session from 'express-session';\nimport connectPgSimple from 'connect-pg-simple';\nimport { pool } from './db.js';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport multer from 'multer';\nimport sharp from 'sharp';\nimport passport from './services/auth.js';\nimport { storage } from './storage.js';\nimport { syncService } from './services/sync.js';\nimport { geminiService } from './services/gemini.js';\nimport { createOpenRouterService } from './services/openrouter.js';\nimport { rateLimiter } from './services/rate-limiter.js';\nimport { googleService } from './services/google.js';\nimport { PhotoEnrichmentService } from './services/photo-enrichment.js';\nimport { taskAI } from './services/task-ai.js';\nimport { taskScheduler } from './services/task-scheduler.js';\nimport { requireAuth, setAuthCookie, clearAuthCookie } from './services/jwt-auth.js';\nimport {\n  generalRateLimit,\n  authRateLimit,\n  apiRateLimit,\n  uploadRateLimit,\n  aiRateLimit,\n  csrfProtection,\n  generateCSRFToken,\n  validateContactId,\n  validateInteractionCreation,\n  handleValidationErrors,\n  securityHeaders,\n  validateFileUpload,\n  safeFileOperation,\n  sanitizeResponse,\n} from './services/security.js';\nimport { nullsToUndefined, safeAnalysisData } from './utils/api-helpers.js';\nimport { z } from 'zod';\nimport { createContactSchema, updateContactSchema } from './schemas/contact.schemas.js';\n\nexport async function registerRoutes(app: express.Application): Promise<Server> {\n  // Security headers\n  app.use(securityHeaders);\n\n  // General rate limiting\n  app.use(generalRateLimit);\n\n  // Serve static files for uploaded photos\n  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));\n\n  // Cookie parser for JWT tokens\n  app.use(cookieParser());\n\n  // Session middleware with PostgreSQL store (fixes critical memory leak)\n  const PgStore = connectPgSimple(session);\n  const store = new PgStore({\n    pool,\n    tableName: 'user_sessions', // Name of the session table\n    createTableIfMissing: true,\n  });\n\n  const SESSION_SECRET = process.env.SESSION_SECRET;\n  if (!SESSION_SECRET) {\n    throw new Error('SESSION_SECRET environment variable is required for security');\n  }\n\n  app.use(\n    session({\n      store,\n      secret: SESSION_SECRET,\n      resave: false,\n      saveUninitialized: false,\n      cookie: {\n        secure: process.env.NODE_ENV === 'production',\n        httpOnly: true,\n        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days\n      },\n    })\n  );\n\n  // Passport configuration (for OAuth only)\n  app.use(passport.initialize());\n  app.use(passport.session());\n\n  // Start sync service and task scheduler\n  syncService.start();\n  taskScheduler.start();\n\n  // CSRF token endpoint\n  app.get('/api/csrf-token', generateCSRFToken);\n\n  // Auth routes with rate limiting\n  app.get('/auth/google', authRateLimit, passport.authenticate('google'));\n\n  app.get(\n    '/auth/google/callback',\n    authRateLimit,\n    passport.authenticate('google', { failureRedirect: '/login' }),\n    (req: Request, res: Response) => {\n      // Set JWT cookie after successful OAuth\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'Authentication failed' });\n      }\n      setAuthCookie(res, req.user.id);\n      res.redirect('/');\n    }\n  );\n\n  app.post('/api/auth/logout', authRateLimit, csrfProtection, (req: Request, res: Response) => {\n    clearAuthCookie(res);\n    res.json({ success: true });\n  });\n\n  app.get('/api/auth/user', apiRateLimit, requireAuth, (req: Request, res: Response) => {\n    res.json(sanitizeResponse(req.user));\n  });\n\n  // Profile management\n  app.get('/api/profile', apiRateLimit, requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const userProfile = await storage.getUserById(user.id);\n      console.log('Profile fetch successful:', {\n        userId: user.id,\n        allowProfilePictureScraping: userProfile?.allowProfilePictureScraping,\n        hasProfile: !!userProfile,\n      });\n      res.json(nullsToUndefined(userProfile));\n    } catch (error: unknown) {\n      console.error('Profile fetch error:', error);\n      res.status(500).json({ error: 'Failed to fetch profile' });\n    }\n  });\n\n  app.patch(\n    '/api/profile/gdpr-consent',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const { allowProfilePictureScraping, gdprConsentDate, gdprConsentVersion } = req.body as {\n          allowProfilePictureScraping: boolean;\n          gdprConsentDate: string;\n          gdprConsentVersion: string;\n        };\n\n        console.log('GDPR consent update request:', {\n          userId: user.id,\n          allowProfilePictureScraping,\n          gdprConsentDate,\n          gdprConsentVersion,\n        });\n\n        // Validate required fields\n        if (typeof allowProfilePictureScraping !== 'boolean') {\n          return res.status(400).json({ error: 'allowProfilePictureScraping must be a boolean' });\n        }\n\n        if (!gdprConsentDate) {\n          return res.status(400).json({ error: 'gdprConsentDate is required' });\n        }\n\n        if (!gdprConsentVersion) {\n          return res.status(400).json({ error: 'gdprConsentVersion is required' });\n        }\n\n        // Parse and validate the date\n        const consentDate = new Date(gdprConsentDate);\n        if (isNaN(consentDate.getTime())) {\n          return res.status(400).json({ error: 'gdprConsentDate must be a valid date' });\n        }\n\n        const updatedUser = await storage.updateUserGdprConsent(user.id, {\n          allowProfilePictureScraping,\n          gdprConsentDate: consentDate,\n          gdprConsentVersion,\n        });\n\n        console.log('GDPR consent update successful:', updatedUser.allowProfilePictureScraping);\n        res.json(nullsToUndefined(updatedUser));\n      } catch (error: unknown) {\n        logError('GDPR consent update error', error);\n        res.status(500).json(createErrorResponse('Failed to update GDPR consent', error, true));\n      }\n    }\n  );\n\n  // Dashboard stats\n  app.get('/api/dashboard/stats', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'Unauthorized' });\n      }\n      const user = req.user!; // Safe after type guard check\n      console.log('Fetching stats for user:', user.id);\n      const stats = await storage.getStats(user.id);\n      res.json(nullsToUndefined(stats));\n    } catch (error: unknown) {\n      logError('Dashboard stats error', error);\n      res.status(500).json(createErrorResponse('Failed to fetch stats', error, true));\n    }\n  });\n\n  // Contacts\n  app.get('/api/contacts', apiRateLimit, requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'Unauthorized' });\n      }\n      const user = req.user!; // Safe after type guard check\n      const contacts = await storage.getContactsByUserId(user.id);\n      res.json(sanitizeResponse(contacts));\n    } catch (error: unknown) {\n      logError('Failed to fetch contacts', error);\n      res.status(500).json(createErrorResponse('Failed to fetch contacts', error, true));\n    }\n  });\n\n  app.get(\n    '/api/contacts/:id',\n    apiRateLimit,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        const contact = await storage.getContact(req.params.id);\n        if (!contact) {\n          return res.status(404).json({ error: 'Contact not found' });\n        }\n\n        const [interactions, goals, documents] = await Promise.all([\n          storage.getInteractionsByContactId(contact.id),\n          storage.getGoalsByContactId(contact.id),\n          storage.getDocumentsByContactId(contact.id),\n        ]);\n\n        res.json(\n          nullsToUndefined(\n            sanitizeResponse({\n              ...contact,\n              interactions,\n              goals,\n              documents,\n            })\n          )\n        );\n      } catch (error: unknown) {\n        logError('Failed to fetch contact details', error);\n        res.status(500).json(createErrorResponse('Failed to fetch contact details', error, true));\n      }\n    }\n  );\n\n  app.post(\n    '/api/contacts',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        // 1. Validate and get typed data using Zod schema\n        const contactData = createContactSchema.parse(req.body);\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n\n        // 2. Use the validated data with userId\n        const contact = await storage.createContact({ ...contactData, userId: user.id });\n        res.json(nullsToUndefined(sanitizeResponse(contact)));\n      } catch (error: unknown) {\n        if (error instanceof z.ZodError) {\n          return res.status(400).json({\n            error: 'Validation failed',\n            details: error.errors,\n          });\n        }\n        console.error('Contact creation error:', error);\n        res.status(500).json({ error: 'Failed to create contact' });\n      }\n    }\n  );\n\n  app.patch(\n    '/api/contacts/:id',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        // 1. Extract tags separately from the request body\n        const { tags, ...requestBody } = req.body as { tags?: unknown[]; [key: string]: unknown };\n        \n        // 2. Validate and get typed data using Zod schema\n        const contactData = updateContactSchema.parse(requestBody);\n\n        // 3. Update the basic contact information\n        await storage.updateContact(req.params.id, contactData);\n\n        // Handle tags if provided\n        if (tags && Array.isArray(tags)) {\n          // Get current contact to see what tags it has\n          const currentContact = await storage.getContact(req.params.id);\n          const currentTags = currentContact?.tags ?? [];\n\n          // Remove all current tags from this contact\n          for (const currentTag of currentTags) {\n            await storage.removeTagFromContact(req.params.id, currentTag.id);\n          }\n\n          // Get all existing tags for reference\n          const existingTags = await storage.getAllTags();\n\n          // Then add the new tags\n          for (const tag of tags) {\n            const typedTag = tag as { id: string; name: string; color?: string };\n            let tagId = typedTag.id;\n\n            // If it's a temporary tag (starts with 'temp_'), create it first\n            if (typedTag.id.startsWith('temp_')) {\n              // Check if a tag with this name already exists\n              const existingTag = existingTags.find(\n                (t) => t.name.toLowerCase() === typedTag.name.toLowerCase()\n              );\n              if (existingTag) {\n                tagId = existingTag.id;\n              } else {\n                // Create new tag\n                const newTag = await storage.createTag({\n                  name: typedTag.name,\n                  color: typedTag.color ?? '#3b82f6',\n                });\n                tagId = newTag.id;\n              }\n            }\n\n            // Add tag to contact (only if not already present)\n            try {\n              await storage.addTagToContact(req.params.id, tagId);\n            } catch (error: unknown) {\n              // Ignore duplicate key errors - tag already exists for this contact\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              if (!errorMessage.includes('duplicate') && !errorMessage.includes('unique')) {\n                throw error;\n              }\n            }\n          }\n        }\n\n        // Return the updated contact with tags\n        const updatedContact = await storage.getContact(req.params.id);\n        res.json(nullsToUndefined(sanitizeResponse(updatedContact)));\n      } catch (error: unknown) {\n        if (error instanceof z.ZodError) {\n          return res.status(400).json({\n            error: 'Validation failed',\n            details: error.errors,\n          });\n        }\n        console.error('Contact update error:', error);\n        res.status(500).json({ error: 'Failed to update contact' });\n      }\n    }\n  );\n\n  app.delete(\n    '/api/contacts/:id',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        const success = await storage.deleteContact(req.params.id);\n        if (success) {\n          res.json({ success: true });\n        } else {\n          res.status(404).json({ error: 'Contact not found' });\n        }\n      } catch (error: unknown) {\n        console.error('Failed to delete contact:', error);\n        res.status(500).json({\n          error: 'Failed to delete contact',\n          ...(process.env.NODE_ENV === 'development' && {\n            details: error instanceof Error ? error.message : 'Unknown error',\n          }),\n        });\n      }\n    }\n  );\n\n  app.get('/api/contacts/:id/cascade-info', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const contactId = req.params.id;\n      const [interactions, goals, documents, calendarEvents] = await Promise.all([\n        storage.getInteractionsByContactId(contactId),\n        storage.getGoalsByContactId(contactId),\n        storage.getDocumentsByContactId(contactId),\n        storage.getCalendarEventsByContactId(contactId),\n      ]);\n\n      res.json({\n        interactions: interactions.length,\n        goals: goals.length,\n        documents: documents.length,\n        calendarEvents: calendarEvents.length,\n      });\n    } catch (_error: unknown) {\n      res.status(500).json({ error: 'Failed to get cascade info' });\n    }\n  });\n\n  // Configure multer for file uploads\n  const uploadDir = path.join(process.cwd(), 'uploads', 'contact-photos');\n  if (!fs.existsSync(uploadDir)) {\n    fs.mkdirSync(uploadDir, { recursive: true });\n  }\n\n  const upload = multer({\n    dest: 'temp/',\n    limits: {\n      fileSize: 10 * 1024 * 1024, // 10MB limit\n    },\n    fileFilter: (req, file, cb) => {\n      if (file.mimetype.startsWith('image/')) {\n        cb(null, true);\n      } else {\n        cb(new Error('Only image files are allowed'));\n      }\n    },\n  });\n\n  // Photo upload endpoint\n  app.post(\n    '/api/contacts/upload-photo',\n    uploadRateLimit,\n    csrfProtection,\n    requireAuth,\n    upload.single('image'),\n    validateFileUpload,\n    async (req: Request, res: Response) => {\n      try {\n        if (!req.file) {\n          return res.status(400).json({ error: 'No image file provided' });\n        }\n\n        const contactId = (req.body as { contactId: string }).contactId;\n        if (!contactId) {\n          return res.status(400).json({ error: 'Contact ID is required' });\n        }\n\n        // Verify contact exists\n        const contact = await storage.getContact(contactId);\n        if (!contact) {\n          // Clean up uploaded file safely\n          if (safeFileOperation(req.file.path, 'temp/')) {\n            fs.unlinkSync(req.file.path);\n          }\n          return res.status(404).json({ error: 'Contact not found' });\n        }\n\n        // Generate unique filename with safe characters\n        const safeContactId = contactId.replace(/[^a-zA-Z0-9-_]/g, '');\n        const fileName = `${safeContactId}_${Date.now()}.webp`;\n        const outputPath = path.join(uploadDir, fileName);\n\n        // Validate output path is safe\n        if (!safeFileOperation(outputPath, uploadDir)) {\n          if (safeFileOperation(req.file.path, 'temp/')) {\n            fs.unlinkSync(req.file.path);\n          }\n          return res.status(400).json({ error: 'Invalid file path' });\n        }\n\n        // Process image with Sharp: convert to WebP, resize, and optimize\n        await sharp(req.file.path)\n          .resize(400, 400, {\n            fit: 'cover',\n            position: 'center',\n          })\n          .webp({ quality: 85 })\n          .toFile(outputPath);\n\n        // Clean up temp file safely\n        if (safeFileOperation(req.file.path, 'temp/')) {\n          fs.unlinkSync(req.file.path);\n        }\n\n        // Check final file size\n        const stats = fs.statSync(outputPath);\n        if (stats.size > 250 * 1024) {\n          // 250KB\n          // Re-process with lower quality if still too large\n          const tempPath = outputPath + '.tmp';\n          await sharp(outputPath).webp({ quality: 60 }).toFile(tempPath);\n\n          if (safeFileOperation(tempPath, uploadDir)) {\n            fs.renameSync(tempPath, outputPath);\n          }\n        }\n\n        // Create contact photo record\n        const photoRecord = await storage.createContactPhoto({\n          contactId,\n          fileName,\n          filePath: `/uploads/contact-photos/${fileName}`,\n          fileSize: fs.statSync(outputPath).size,\n          mimeType: 'image/webp',\n          source: 'manual',\n          isActive: true,\n        });\n\n        // Update contact avatar URL\n        const avatarUrl = `/uploads/contact-photos/${fileName}`;\n        await storage.updateContact(contactId, { avatarUrl });\n\n        res.json({\n          success: true,\n          avatarUrl,\n          photoId: photoRecord.id,\n          fileSize: photoRecord.fileSize,\n        });\n      } catch (error: unknown) {\n        console.error('Photo upload error:', error);\n\n        // Clean up uploaded file if it exists\n        if (req.file && fs.existsSync(req.file.path) && safeFileOperation(req.file.path, 'temp/')) {\n          fs.unlinkSync(req.file.path);\n        }\n\n        res.status(500).json({\n          error: 'Failed to upload photo',\n          details: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n  );\n\n  // AI photo download endpoint\n  app.post(\n    '/api/contacts/ai-photo-download',\n    aiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        // TODO: Implement AI photo download and processing\n        res.status(501).json({ error: 'AI photo download not yet implemented' });\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to download photo' });\n      }\n    }\n  );\n\n  // Remove contact photo\n  app.delete(\n    '/api/contacts/:id/photo',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        const success = await storage.updateContact(req.params.id, {\n          avatarUrl: null,\n        });\n        if (success) {\n          res.json({ success: true });\n        } else {\n          res.status(404).json({ error: 'Contact not found' });\n        }\n      } catch (error: unknown) {\n        console.error('Failed to delete photo:', error);\n        res.status(500).json({\n          error: 'Failed to delete photo',\n          ...(process.env.NODE_ENV === 'development' && {\n            details: error instanceof Error ? error.message : 'Unknown error',\n          }),\n        });\n      }\n    }\n  );\n\n  // Photo Enrichment Service\n  const photoEnrichmentService = new PhotoEnrichmentService(storage);\n\n  // Batch enrich all contact photos\n  app.post(\n    '/api/photo-enrichment/batch',\n    aiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const results = await photoEnrichmentService.batchEnrichPhotos(user.id);\n        res.json(sanitizeResponse(results));\n      } catch (error: unknown) {\n        console.error('Batch photo enrichment error:', error);\n        res.status(500).json({\n          error: 'Failed to batch enrich photos',\n          details: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n  );\n\n  // Find photo suggestions for a single contact\n  app.get(\n    '/api/contacts/:id/photo-suggestions',\n    apiRateLimit,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        const contact = await storage.getContact(req.params.id);\n        if (!contact) {\n          return res.status(404).json({ error: 'Contact not found' });\n        }\n\n        // Convert database contact to ContactInfo format\n        const contactInfo = {\n          id: contact.id,\n          name: contact.name,\n          email: contact.email,\n          phone: contact.phone ?? null, // Keep null as null, convert undefined to null\n          allowProfilePictureScraping: contact.hasGdprConsent || undefined, // Convert null to undefined\n          // Add other fields if available from JSON fields\n          company:\n            contact.extractedFields && typeof contact.extractedFields === 'object'\n              ? (contact.extractedFields as { company?: string }).company\n              : undefined,\n          linkedinUrl:\n            contact.socialMediaHandles && typeof contact.socialMediaHandles === 'object'\n              ? (contact.socialMediaHandles as { linkedin?: string }).linkedin\n              : undefined,\n          jobTitle:\n            contact.extractedFields && typeof contact.extractedFields === 'object'\n              ? (contact.extractedFields as { jobTitle?: string }).jobTitle\n              : undefined,\n        };\n\n        const suggestions = await photoEnrichmentService.findPhotoSuggestions(contactInfo);\n        res.json({ suggestions });\n      } catch (error: unknown) {\n        console.error('Photo suggestions error:', error);\n        res.status(500).json({ error: 'Failed to find photo suggestions' });\n      }\n    }\n  );\n\n  // Enrich a single contact's photo\n  app.post(\n    '/api/contacts/:id/enrich-photo',\n    aiRateLimit,\n    csrfProtection,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        const result = await photoEnrichmentService.enrichSingleContact(req.params.id);\n        res.json(sanitizeResponse(result));\n      } catch (error: unknown) {\n        console.error('Single photo enrichment error:', error);\n        res.status(500).json({ error: 'Failed to enrich contact photo' });\n      }\n    }\n  );\n\n  // Get enrichment stats\n  app.get(\n    '/api/photo-enrichment/stats',\n    apiRateLimit,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const contacts = await storage.getContactsByUserId(user.id);\n\n        const stats = {\n          totalContacts: contacts.length,\n          contactsWithPhotos: contacts.filter((c) => c.avatarUrl).length,\n          contactsConsented: contacts.filter((c) => c.hasGdprConsent).length,\n          contactsEligible: contacts.filter((c) => c.hasGdprConsent && !c.avatarUrl).length,\n        };\n\n        res.json(sanitizeResponse(stats));\n      } catch (error: unknown) {\n        console.error('Photo enrichment stats error:', error);\n        res.status(500).json({ error: 'Failed to fetch enrichment stats' });\n      }\n    }\n  );\n\n  // Export contacts\n  app.get(\n    '/api/contacts/export',\n    apiRateLimit,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const format = (req.query.format as string) ?? 'json';\n        const contacts = await storage.getContactsByUserId(user.id);\n\n        if (format === 'json') {\n          res.setHeader('Content-Type', 'application/json');\n          res.setHeader('Content-Disposition', 'attachment; filename=\"contacts.json\"');\n          res.json(contacts);\n        } else if (format === 'csv') {\n          // TODO: Implement CSV export\n          res.status(501).json({ error: 'CSV export not yet implemented' });\n        } else {\n          res.status(400).json({ error: 'Unsupported format' });\n        }\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to export contacts' });\n      }\n    }\n  );\n\n  // Export selected contacts\n  app.post('/api/contacts/export-selected', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const { contactIds, format } = req.body;\n      const contacts = await Promise.all(contactIds.map((id: string) => storage.getContact(id)));\n      const validContacts = contacts.filter(Boolean);\n\n      if (format === 'json') {\n        res.setHeader('Content-Type', 'application/json');\n        res.setHeader('Content-Disposition', 'attachment; filename=\"selected-contacts.json\"');\n        res.json(validContacts);\n      } else {\n        res.status(400).json({ error: 'Unsupported format' });\n      }\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to export selected contacts' });\n    }\n  });\n\n  // Recent interactions\n  app.get(\n    '/api/interactions/recent',\n    apiRateLimit,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const limit = Math.min(parseInt(req.query.limit as string) || 10, 100); // Cap at 100\n        const interactions = await storage.getRecentInteractions(user.id, limit);\n        res.json(sanitizeResponse(interactions));\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to fetch recent interactions' });\n      }\n    }\n  );\n\n  // Create interaction\n  app.post(\n    '/api/interactions',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    validateInteractionCreation,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        console.log('Creating interaction with data:', req.body);\n        const interactionData = {\n          ...req.body,\n          timestamp: new Date(req.body.timestamp),\n        };\n        const interaction = await storage.createInteraction(interactionData);\n        res.json(interaction);\n      } catch (error: unknown) {\n        console.error('Create interaction error:', error);\n        res.status(500).json({\n          error: 'Failed to create interaction',\n          details: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n  );\n\n  // Get contact calendar context\n  app.get(\n    '/api/contacts/:contactId/calendar-context',\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const { contactId } = req.params;\n\n        // Get calendar events for this contact\n        const events = await storage.getCalendarEventsByContactId(contactId);\n\n        const now = new Date();\n        const lastEvent = events\n          .filter((event) => event.startTime && new Date(event.startTime) < now)\n          .sort((a, b) => new Date(b.startTime!).getTime() - new Date(a.startTime!).getTime())[0];\n\n        const nextEvent = events\n          .filter((event) => event.startTime && new Date(event.startTime) > now)\n          .sort((a, b) => new Date(a.startTime!).getTime() - new Date(b.startTime!).getTime())[0];\n\n        const last90Days = events.filter((event) => {\n          if (!event.startTime) return false;\n          const eventDate = new Date(event.startTime);\n          const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\n          return eventDate >= ninetyDaysAgo && eventDate <= now;\n        });\n\n        res.json({\n          lastEvent,\n          nextEvent,\n          sessionCount90Days: last90Days.length,\n          totalSessions: events.length,\n        });\n      } catch (error: unknown) {\n        console.error('Error fetching contact calendar context:', error);\n        res.status(500).json({ error: 'Failed to fetch calendar context' });\n      }\n    }\n  );\n\n  // Goals\n  app.post('/api/goals', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const goal = await storage.createGoal(req.body);\n      res.json(goal);\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to create goal' });\n    }\n  });\n\n  app.patch('/api/goals/:id', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const goal = await storage.updateGoal(req.params.id, req.body);\n      res.json(goal);\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to update goal' });\n    }\n  });\n\n  // AI Assistant\n  app.post(\n    '/api/ai/chat',\n    aiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        const { message, context } = req.body;\n        const response = await geminiService.generateChatResponse(message, context);\n        res.json(sanitizeResponse({ response }));\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to generate AI response' });\n      }\n    }\n  );\n\n  app.post(\n    '/api/ai/insights/:contactId',\n    aiRateLimit,\n    csrfProtection,\n    requireAuth,\n    validateContactId,\n    handleValidationErrors,\n    async (req: Request, res: Response) => {\n      try {\n        const contact = await storage.getContact(req.params.contactId);\n        if (!contact) {\n          return res.status(404).json({ error: 'Contact not found' });\n        }\n\n        const [interactions, goals] = await Promise.all([\n          storage.getInteractionsByContactId(contact.id),\n          storage.getGoalsByContactId(contact.id),\n        ]);\n\n        const openRouterWithStorage = createOpenRouterService(storage);\n        \n        // Transform contact data to match ContactData interface\n        const contactData = {\n          id: contact.id,\n          name: contact.name,\n          email: contact.email,\n          phone: contact.phone,\n          avatarUrl: contact.avatarUrl,\n          status: contact.status,\n          lifecycleStage: contact.lifecycleStage,\n          userId: contact.userId,\n          createdAt: contact.createdAt,\n          updatedAt: contact.updatedAt,\n          lastContact: contact.lastContact,\n          sentiment: contact.sentiment,\n          interactions,\n          goals,\n        } as any; // Cast as any since ContactData interface doesn't include interactions/goals\n        \n        const insights = await openRouterWithStorage.generateInsights(contactData);\n\n        res.json(nullsToUndefined(insights));\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to generate insights' });\n      }\n    }\n  );\n\n  // Sync\n  app.get('/api/sync/status', apiRateLimit, requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      console.log('Fetching sync status for user:', user.id);\n      const syncStatus = await storage.getSyncStatus(user.id);\n      res.json(sanitizeResponse(syncStatus));\n    } catch (error: unknown) {\n      console.error('Sync status error:', error);\n      res.status(500).json({\n        error: 'Failed to fetch sync status',\n        details: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  });\n\n  app.post(\n    '/api/sync/manual',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        await syncService.manualSync(user.id);\n        res.json({ success: true });\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Manual sync failed' });\n      }\n    }\n  );\n  // Calendar Events\n  app.get('/api/calendar/events', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const month = req.query.month as string;\n\n      // Get all events for the user\n      const allEvents = await storage.getCalendarEventsByUserId(user.id);\n\n      // Filter by month if specified\n      let events = allEvents;\n      if (month) {\n        const targetDate = new Date(month);\n        const targetYear = targetDate.getFullYear();\n        const targetMonth = targetDate.getMonth();\n\n        events = allEvents.filter((event) => {\n          if (!event.startTime) return false;\n          const eventDate = new Date(event.startTime);\n          return eventDate.getFullYear() === targetYear && eventDate.getMonth() === targetMonth;\n        });\n      }\n\n      res.json(events);\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to fetch calendar events' });\n    }\n  });\n\n  // Get upcoming calendar events for dashboard\n  app.get('/api/calendar/upcoming', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const limit = parseInt(req.query.limit as string) || 5;\n\n      // Get all events for the user\n      const allEvents = await storage.getCalendarEventsByUserId(user.id, 100);\n\n      // Filter for future events and sort by start time\n      const now = new Date();\n      const upcomingEvents = allEvents\n        .filter((event) => event.startTime && new Date(event.startTime) > now)\n        .sort((a, b) => new Date(a.startTime!).getTime() - new Date(b.startTime!).getTime())\n        .slice(0, limit);\n\n      res.json(upcomingEvents);\n    } catch (error: unknown) {\n      console.error('Error fetching upcoming events:', error);\n      res.status(500).json({ error: 'Failed to fetch upcoming events' });\n    }\n  });\n\n  app.post('/api/calendar/events', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const eventData = { ...req.body, userId: user.id };\n      const event = await storage.createCalendarEvent(eventData);\n      res.json(event);\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to create calendar event' });\n    }\n  });\n\n  app.post('/api/calendar/sync', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      console.log(`Starting ongoing calendar sync for user ${user.id}`);\n\n      // Sync only recent changes (last 7 days + future events)\n      await syncService.syncCalendar(user.id);\n\n      // Process new events with intelligent model selection\n      const openRouterWithStorage = createOpenRouterService(storage);\n      const contacts = await storage.getContactsByUserId(user.id);\n      const unprocessedEvents = await storage.getUnprocessedCalendarEvents(user.id);\n\n      if (unprocessedEvents.length > 0) {\n        console.log(`Processing ${unprocessedEvents.length} new events`);\n\n        // For ongoing sync, use premium model for better accuracy\n        const results = await openRouterWithStorage.processCalendarEvents(\n          unprocessedEvents,\n          contacts,\n          user.id,\n          false\n        );\n\n        // Mark processed events\n        for (const event of unprocessedEvents) {\n          const result = results.find((r) => r.eventId === event.id);\n          await storage.markCalendarEventProcessed(\n            event.id,\n            result || ({} as Record<string, unknown>)\n          );\n        }\n\n        // Get updated usage stats\n        const usageStats = await rateLimiter.getUsageStats(user.id);\n\n        res.json({\n          success: true,\n          message: `Sync completed. Processed ${results.length} relevant events from ${unprocessedEvents.length} new events.`,\n          newEvents: unprocessedEvents.length,\n          relevantEvents: results.length,\n          usageStats,\n          recommendations: usageStats.recommendations,\n        });\n      } else {\n        res.json({\n          success: true,\n          message: 'Sync completed. No new events to process.',\n        });\n      }\n    } catch (error: unknown) {\n      console.error('Calendar sync error:', error);\n      res.status(500).json({ error: 'Failed to sync calendar' });\n    }\n  });\n\n  // Enhanced Calendar Routes for Raw Google Data\n  app.get('/api/calendar/raw-events', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const limit = parseInt(req.query.limit as string) || 100;\n      const events = await storage.getCalendarEventsByUserId(user.id, limit);\n      res.json(events);\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to fetch raw calendar events' });\n    }\n  });\n\n  app.post('/api/calendar/sync-initial', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const { months = 12, useFreeModel = true } = req.body; // Default to 1 year, use free model for bulk\n\n      console.log(`Starting initial ${months}-month calendar sync for user ${user.id}`);\n\n      // Validate months parameter\n      if (months < 1 || months > 24) {\n        return res.status(400).json({ error: 'Months must be between 1 and 24' });\n      }\n\n      // Calculate date range for initial sync\n      const now = new Date();\n      const startDate = new Date(now.getTime() - months * 30 * 24 * 60 * 60 * 1000);\n      const endDate = new Date(now.getTime() + 6 * 30 * 24 * 60 * 60 * 1000); // 6 months forward\n\n      // Sync historical data with custom date range\n      await googleService.syncCalendar(user, {\n        startDate,\n        endDate,\n        syncType: 'initial',\n      });\n\n      // Process events with intelligent rate limiting and model selection\n      const openRouterWithStorage = createOpenRouterService(storage);\n      const contacts = await storage.getContactsByUserId(user.id);\n      const events = await storage.getUnprocessedCalendarEvents(user.id);\n\n      // Get usage stats and recommendations\n      const usageStats = await rateLimiter.getUsageStats(user.id);\n      console.log('Current usage stats:', usageStats);\n\n      // Process in batches with rate limiting\n      const batchSize = 25; // Smaller batches for better rate limit management\n      let processedCount = 0;\n\n      for (let i = 0; i < events.length; i += batchSize) {\n        const batch = events.slice(i, i + batchSize);\n        console.log(\n          `Processing batch ${Math.floor(i / batchSize) + 1} of ${Math.ceil(\n            events.length / batchSize\n          )}`\n        );\n\n        const results = await openRouterWithStorage.processCalendarEvents(\n          batch,\n          contacts,\n          user.id,\n          useFreeModel\n        );\n        processedCount += results.length;\n\n        // Mark processed events in calendar_events table\n        for (const event of batch) {\n          await storage.markCalendarEventProcessed(\n            event.id,\n            safeAnalysisData(results.find((r) => r.eventId === event.id))\n          );\n        }\n      }\n\n      res.json({\n        success: true,\n        message: `Historical sync completed. Processed ${processedCount} relevant events from ${events.length} total events.`,\n        totalEvents: events.length,\n        relevantEvents: processedCount,\n        monthsProcessed: months,\n      });\n    } catch (error: unknown) {\n      console.error('Historical calendar sync error:', error);\n      res.status(500).json({ error: 'Failed to sync historical calendar data' });\n    }\n  });\n\n  app.post('/api/calendar/process-events', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const { usePremiumModel = true, batchSize = 25 } = req.body;\n\n      console.log(`Starting intelligent LLM processing for user ${user.id}`);\n\n      const openRouterWithStorage = createOpenRouterService(storage);\n      const contacts = await storage.getContactsByUserId(user.id);\n      const events = await storage.getUnprocessedCalendarEvents(user.id);\n\n      if (events.length === 0) {\n        return res.json({\n          success: true,\n          message: 'No unprocessed events found',\n        });\n      }\n\n      // Check current usage and get recommendations\n      const usageStats = await rateLimiter.getUsageStats(user.id);\n\n      let processedCount = 0;\n\n      // Process in smaller batches for ongoing processing\n      for (let i = 0; i < events.length; i += batchSize) {\n        const batch = events.slice(i, i + batchSize);\n        console.log(\n          `Processing batch ${Math.floor(i / batchSize) + 1} of ${Math.ceil(\n            events.length / batchSize\n          )}`\n        );\n\n        const results = await openRouterWithStorage.processCalendarEvents(\n          batch,\n          contacts,\n          user.id,\n          !usePremiumModel\n        );\n        processedCount += results.length;\n\n        // Mark processed events\n        for (const event of batch) {\n          await storage.markCalendarEventProcessed(\n            event.id,\n            safeAnalysisData(results.find((r) => r.eventId === event.id))\n          );\n        }\n      }\n\n      res.json({\n        success: true,\n        message: `Event processing completed. Processed ${processedCount} relevant events from ${events.length} total events.`,\n        totalEvents: events.length,\n        relevantEvents: processedCount,\n        modelUsed: usePremiumModel ? 'qwen3-235b' : 'llama-3.1-8b-free',\n      });\n    } catch (error: unknown) {\n      console.error('Event processing error:', error);\n      res.status(500).json({ error: 'Failed to process calendar events' });\n    }\n  });\n\n  app.get('/api/calendar/unprocessed-count', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const events = await storage.getUnprocessedCalendarEvents(user.id);\n      res.json({ count: events.length });\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to get unprocessed events count' });\n    }\n  });\n\n  app.get('/api/calendar/sync-stats', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n\n      // Get total events\n      const allEvents = await storage.getCalendarEventsByUserId(user.id, 1000);\n      const unprocessedEvents = await storage.getUnprocessedCalendarEvents(user.id);\n\n      // Calculate date ranges\n      const now = new Date();\n      const oneYearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);\n      const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n      // Filter events by date ranges\n      const eventsLastYear = allEvents.filter(\n        (e) => e.startTime && new Date(e.startTime) >= oneYearAgo\n      );\n      const eventsLastMonth = allEvents.filter(\n        (e) => e.startTime && new Date(e.startTime) >= oneMonthAgo\n      );\n      const futureEvents = allEvents.filter((e) => e.startTime && new Date(e.startTime) > now);\n\n      res.json({\n        totalEvents: allEvents.length,\n        processedEvents: allEvents.length - unprocessedEvents.length,\n        unprocessedEvents: unprocessedEvents.length,\n        eventsLastYear: eventsLastYear.length,\n        eventsLastMonth: eventsLastMonth.length,\n        futureEvents: futureEvents.length,\n        oldestEvent: allEvents.length > 0 ? allEvents[allEvents.length - 1]?.startTime : null,\n        newestEvent: allEvents.length > 0 ? allEvents[0]?.startTime : null,\n      });\n    } catch (error: unknown) {\n      console.error('Sync stats error:', error);\n      res.status(500).json({ error: 'Failed to get sync statistics' });\n    }\n  });\n\n  // Rate limiting and usage stats endpoint\n  app.get('/api/rate-limit/usage', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const usageStats = await rateLimiter.getUsageStats(user.id);\n      res.json(usageStats);\n    } catch (error: unknown) {\n      console.error('Usage stats error:', error);\n      res.status(500).json({ error: 'Failed to get usage statistics' });\n    }\n  });\n\n  // Get model recommendations\n  app.post('/api/rate-limit/recommend', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const { eventCount, isHistoricalSync } = req.body;\n      const recommendedModel = rateLimiter.getRecommendedModel(\n        eventCount || 0,\n        isHistoricalSync || false\n      );\n\n      res.json({\n        recommendedModel,\n        isFreeModel: recommendedModel.includes('free'),\n        reason:\n          isHistoricalSync || eventCount > 50\n            ? 'Free model recommended for bulk processing to manage costs'\n            : 'Premium model recommended for better accuracy on smaller batches',\n      });\n    } catch (error: unknown) {\n      console.error('Model recommendation error:', error);\n      res.status(500).json({ error: 'Failed to get model recommendation' });\n    }\n  });\n\n  // Email Data Processing (for AI insights, not email management)\n  app.get(\n    '/api/emails/processed',\n    apiRateLimit,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const limit = Math.min(parseInt(req.query.limit as string) || 50, 200); // Cap at 200\n        const emails = await storage.getEmailsByUserId(user.id, limit);\n        // Only return processed emails with extracted data\n        const processedEmails = emails.filter((email) => email.processed && email.extractedData);\n        res.json(sanitizeResponse(processedEmails));\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to fetch processed emails' });\n      }\n    }\n  );\n\n  app.get(\n    '/api/emails/unprocessed',\n    apiRateLimit,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        const emails = await storage.getUnprocessedEmails(user.id);\n        res.json(sanitizeResponse(emails));\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to fetch unprocessed emails' });\n      }\n    }\n  );\n\n  app.patch(\n    '/api/emails/:id/mark-processed',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        const { extractedData, relevanceScore, filterReason } = req.body;\n        const email = await storage.markEmailProcessed(req.params.id, {\n          extractedData,\n          relevanceScore,\n          filterReason,\n        });\n        res.json(sanitizeResponse(email));\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to mark email as processed' });\n      }\n    }\n  );\n\n  app.post(\n    '/api/emails/sync',\n    apiRateLimit,\n    csrfProtection,\n    requireAuth,\n    async (req: Request, res: Response) => {\n      try {\n        if (!isAuthenticatedUser(req.user)) {\n          return res.status(401).json({ error: 'User not authenticated' });\n        }\n        const user = req.user;\n        await syncService.syncEmails(user.id);\n        res.json({ success: true });\n      } catch (error: unknown) {\n        res.status(500).json({ error: 'Failed to sync emails' });\n      }\n    }\n  );\n\n  // Tags\n  app.get('/api/tags', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const tags = await storage.getAllTags();\n      res.json(tags);\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to fetch tags' });\n    }\n  });\n\n  app.post('/api/tags', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const { name, color } = req.body;\n      console.log('Creating tag:', { name, color });\n\n      if (!name?.trim()) {\n        return res.status(400).json({ error: 'Tag name is required' });\n      }\n\n      const tag = await storage.createTag({\n        name: name.trim(),\n        color: color ?? '#3b82f6',\n      });\n      console.log('Tag created successfully:', tag);\n      res.json(tag);\n    } catch (error: unknown) {\n      console.error('Tag creation error:', error);\n\n      // Handle specific database errors\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      if (errorMessage.includes('duplicate') || errorMessage.includes('unique')) {\n        return res.status(409).json({ error: 'A tag with this name already exists' });\n      }\n\n      res.status(500).json({ error: 'Failed to create tag' });\n    }\n  });\n\n  app.post('/api/contacts/bulk/add-tag', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const { contactIds, tagId, tagName, tagColor } = req.body;\n\n      let finalTagId = tagId;\n\n      // Create new tag if tagName is provided but no tagId\n      if (!tagId && tagName) {\n        const newTag = await storage.createTag({\n          name: tagName,\n          color: tagColor ?? '#3b82f6',\n        });\n        finalTagId = newTag.id;\n      }\n\n      if (!finalTagId) {\n        return res.status(400).json({ error: 'Tag ID or tag name is required' });\n      }\n\n      const contactTags = await storage.addTagToContacts(contactIds, finalTagId);\n      res.json({ success: true, contactTags, tagId: finalTagId });\n    } catch (error: unknown) {\n      console.error('Bulk add tag error:', error);\n      res.status(500).json({ error: 'Failed to add tag to contacts' });\n    }\n  });\n\n  app.post('/api/contacts/bulk/remove-tag', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const { contactIds, tagId } = req.body;\n      const success = await storage.removeTagFromContacts(contactIds, tagId);\n      res.json({ success });\n    } catch (error: unknown) {\n      res.status(500).json({ error: 'Failed to remove tag from contacts' });\n    }\n  });\n\n  // ===== TASK MANAGEMENT API ROUTES =====\n\n  // Projects\n  app.get('/api/projects', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const projects = await storage.getProjectsByUserId(user.id);\n      res.json(projects);\n    } catch (error: unknown) {\n      console.error('Get projects error:', error);\n      res.status(500).json({ error: 'Failed to fetch projects' });\n    }\n  });\n\n  app.post('/api/projects', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const projectData = { ...req.body, userId: user.id };\n      const project = await storage.createProject(projectData);\n      res.json(project);\n    } catch (error: unknown) {\n      console.error('Create project error:', error);\n      res.status(500).json({ error: 'Failed to create project' });\n    }\n  });\n\n  app.patch('/api/projects/:id', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const project = await storage.updateProject(req.params.id, req.body);\n      res.json(project);\n    } catch (error: unknown) {\n      console.error('Update project error:', error);\n      res.status(500).json({ error: 'Failed to update project' });\n    }\n  });\n\n  app.delete('/api/projects/:id', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const success = await storage.deleteProject(req.params.id);\n      res.json({ success });\n    } catch (error: unknown) {\n      console.error('Delete project error:', error);\n      res.status(500).json({ error: 'Failed to delete project' });\n    }\n  });\n\n  // Tasks\n  app.get('/api/tasks', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const { status, project, owner } = req.query;\n\n      let tasks;\n      if (project) {\n        tasks = await storage.getTasksByProjectId(project as string);\n      } else if (status && owner) {\n        // Validate enum values\n        const validStatuses = [\n          'pending',\n          'in_progress',\n          'completed',\n          'cancelled',\n          'waiting_approval',\n        ] as const;\n        const validOwners = ['user', 'ai_assistant'] as const;\n\n        const statusStr = status as string;\n        const ownerStr = owner as string;\n\n        if (!validStatuses.includes(statusStr as (typeof validStatuses)[number])) {\n          return res\n            .status(400)\n            .json({ error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` });\n        }\n\n        if (!validOwners.includes(ownerStr as (typeof validOwners)[number])) {\n          return res\n            .status(400)\n            .json({ error: `Invalid owner. Must be one of: ${validOwners.join(', ')}` });\n        }\n\n        tasks = await storage.getTasksByStatus(\n          statusStr as (typeof validStatuses)[number],\n          ownerStr as (typeof validOwners)[number]\n        );\n      } else {\n        const statuses = status ? (status as string).split(',') : undefined;\n        tasks = await storage.getTasksByUserId(user.id, statuses);\n      }\n\n      res.json(tasks);\n    } catch (error: unknown) {\n      console.error('Get tasks error:', error);\n      res.status(500).json({ error: 'Failed to fetch tasks' });\n    }\n  });\n\n  app.get('/api/tasks/:id', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const task = await storage.getTask(req.params.id);\n      if (!task) {\n        return res.status(404).json({ error: 'Task not found' });\n      }\n\n      // Get subtasks and activities\n      const [subtasks, activities] = await Promise.all([\n        storage.getSubtasks(task.id),\n        storage.getTaskActivities(task.id),\n      ]);\n\n      res.json({ ...task, subtasks, activities });\n    } catch (error: unknown) {\n      console.error('Get task error:', error);\n      res.status(500).json({ error: 'Failed to fetch task' });\n    }\n  });\n\n  app.post('/api/tasks', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const requestBody = req.body as {\n        title?: string;\n        description?: string;\n        priority?: 'low' | 'medium' | 'high' | 'urgent';\n        owner?: 'user' | 'ai_assistant';\n        dueDate?: string;\n        projectId?: string;\n        assignedContactIds?: string[];\n      };\n      \n      // Ensure required fields are provided\n      if (!requestBody.title) {\n        return res.status(400).json({ error: 'Title is required' });\n      }\n      \n      const taskData = { \n        ...requestBody, \n        userId: user.id,\n        title: requestBody.title,\n        dueDate: requestBody.dueDate ? new Date(requestBody.dueDate) : undefined\n      };\n\n      const task = await storage.createTask(taskData);\n\n      // Create activity log for task creation\n      await storage.createTaskActivity({\n        taskId: task.id,\n        actorType: 'user',\n        actorId: user.id,\n        actionType: 'created',\n        description: `Task created: ${task.title}`,\n        metadata: { priority: task.priority, owner: task.owner },\n      });\n\n      res.json(task);\n    } catch (error: unknown) {\n      console.error('Create task error:', error);\n      res.status(500).json({ error: 'Failed to create task' });\n    }\n  });\n\n  app.patch('/api/tasks/:id', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const updates = req.body as {\n        title?: string;\n        description?: string;\n        status?: 'pending' | 'in_progress' | 'completed' | 'cancelled' | 'waiting_approval';\n        priority?: 'low' | 'medium' | 'high' | 'urgent';\n        completedAt?: string | Date;\n        dueDate?: string;\n        [key: string]: unknown;\n      };\n      \n      // Convert string dates to Date objects if provided\n      const processedUpdates = {\n        ...updates,\n        dueDate: updates.dueDate ? new Date(updates.dueDate) : undefined,\n        completedAt: updates.completedAt ? new Date(updates.completedAt) : undefined\n      };\n\n      const task = await storage.updateTask(req.params.id, processedUpdates);\n\n      // Create activity log for task update\n      const activityDescription = Object.keys(updates)\n        .map((key) => {\n          const value = updates[key];\n          if (key === 'status') return `Status changed to ${String(value)}`;\n          if (key === 'priority') return `Priority changed to ${String(value)}`;\n          if (key === 'completedAt' && value) return 'Task completed';\n          return `${key} updated`;\n        })\n        .join(', ');\n\n      await storage.createTaskActivity({\n        taskId: task.id,\n        actorType: 'user',\n        actorId: user.id,\n        actionType: 'updated',\n        description: activityDescription,\n        metadata: updates as Record<string, unknown>,\n      });\n\n      res.json(task);\n    } catch (error: unknown) {\n      console.error('Update task error:', error);\n      res.status(500).json({ error: 'Failed to update task' });\n    }\n  });\n\n  app.delete('/api/tasks/:id', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const success = await storage.deleteTask(req.params.id);\n      res.json({ success });\n    } catch (error: unknown) {\n      console.error('Delete task error:', error);\n      res.status(500).json({ error: 'Failed to delete task' });\n    }\n  });\n\n  // Task delegation to AI\n  app.post('/api/tasks/delegate-to-ai', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const requestBody = req.body as {\n        title?: string;\n        description?: string;\n        contactIds?: string[];\n        dueDate?: string;\n        projectId?: string;\n        priority?: 'low' | 'medium' | 'high' | 'urgent';\n      };\n      const { title, description, contactIds, dueDate, projectId, priority } = requestBody;\n\n      const task = await taskAI.delegateTaskToAI(user.id, {\n        title: title ?? '',\n        description: description ?? '',\n        contactIds: contactIds ?? [],\n        dueDate: dueDate ? new Date(dueDate) : undefined,\n        projectId: projectId ?? undefined,\n        priority: (priority as 'low' | 'medium' | 'high' | 'urgent') ?? 'medium',\n      });\n\n      res.json({\n        success: true,\n        task,\n        message: 'Task successfully delegated to AI assistant. Processing will begin shortly.',\n      });\n    } catch (error: unknown) {\n      console.error('Delegate task to AI error:', error);\n      res.status(500).json({ error: 'Failed to delegate task to AI' });\n    }\n  });\n\n  // Bulk task creation from contacts\n  app.post('/api/tasks/bulk-create', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const requestBody = req.body as {\n        title?: string;\n        description?: string;\n        contactIds?: string[];\n        dueDate?: string;\n        projectId?: string;\n        owner?: string;\n      };\n      const { title, description, contactIds, dueDate, projectId, owner } = requestBody;\n\n      if (owner === 'ai_assistant') {\n        // Delegate to AI for processing\n        const task = await taskAI.delegateTaskToAI(user.id, {\n          title: title ?? '',\n          description: description ?? '',\n          contactIds: contactIds ?? [],\n          dueDate: dueDate ? new Date(dueDate) : undefined,\n          projectId: projectId ?? undefined,\n        });\n\n        res.json({\n          success: true,\n          task,\n          message: 'Bulk task delegated to AI for processing',\n        });\n      } else {\n        // Create regular user task\n        const task = await storage.createTask({\n          userId: user.id,\n          title: title ?? '',\n          description: description ?? '',\n          assignedContactIds: contactIds ?? [],\n          dueDate: dueDate ? new Date(dueDate) : undefined,\n          projectId: projectId ?? undefined,\n          owner: 'user',\n        });\n\n        const contactCount = contactIds?.length ?? 0;\n        await storage.createTaskActivity({\n          taskId: task.id,\n          actorType: 'user',\n          actorId: user.id,\n          actionType: 'created',\n          description: `Bulk task created for ${contactCount} contacts`,\n          metadata: { contactCount },\n        });\n\n        res.json({ success: true, task });\n      }\n    } catch (error: unknown) {\n      console.error('Bulk create task error:', error);\n      res.status(500).json({ error: 'Failed to create bulk task' });\n    }\n  });\n\n  // AI Suggestions\n  app.get('/api/ai-suggestions', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const { status } = req.query;\n\n      const suggestions = await storage.getAiSuggestionsByUserId(user.id, status as string);\n      res.json(suggestions);\n    } catch (error: unknown) {\n      console.error('Get AI suggestions error:', error);\n      res.status(500).json({ error: 'Failed to fetch AI suggestions' });\n    }\n  });\n\n  app.patch('/api/ai-suggestions/:id/approve', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const suggestion = await storage.updateAiSuggestion(req.params.id, {\n        status: 'approved',\n        reviewedAt: new Date(),\n      });\n\n      // Execute the approved suggestion\n      const success = await taskAI.executeAISuggestion(req.params.id);\n\n      res.json({\n        success,\n        suggestion,\n        message: success\n          ? 'Suggestion approved and executed'\n          : 'Suggestion approved but execution failed',\n      });\n    } catch (error: unknown) {\n      console.error('Approve AI suggestion error:', error);\n      res.status(500).json({ error: 'Failed to approve AI suggestion' });\n    }\n  });\n\n  app.patch('/api/ai-suggestions/:id/reject', requireAuth, async (req: Request, res: Response) => {\n    try {\n      const requestBody = req.body as { reason?: string };\n      const { reason } = requestBody;\n      const suggestion = await storage.updateAiSuggestion(req.params.id, {\n        status: 'rejected',\n        reviewedAt: new Date(),\n        rejectionReason: reason ?? '',\n      });\n\n      res.json({ success: true, suggestion });\n    } catch (error: unknown) {\n      console.error('Reject AI suggestion error:', error);\n      res.status(500).json({ error: 'Failed to reject AI suggestion' });\n    }\n  });\n\n  // Data Processing and Background Jobs\n  app.post('/api/data-processing/attendance-csv', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const requestBody = req.body as { csvData?: string; fileName?: string };\n      const { csvData, fileName } = requestBody;\n      \n      if (!csvData || !fileName) {\n        return res.status(400).json({ error: 'csvData and fileName are required' });\n      }\n\n      const suggestions = await taskAI.processAttendanceCSV(user.id, csvData, fileName);\n\n      res.json({\n        success: true,\n        suggestionsCreated: suggestions.length,\n        suggestions,\n      });\n    } catch (error: unknown) {\n      console.error('Process attendance CSV error:', error);\n      res.status(500).json({ error: 'Failed to process attendance CSV' });\n    }\n  });\n\n  app.post('/api/data-processing/photo-gdpr', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const requestBody = req.body as { \n        photoData?: { contactId: string; photoUrl: string; source: string; }[] \n      };\n      const { photoData } = requestBody;\n      \n      if (!photoData || !Array.isArray(photoData)) {\n        return res.status(400).json({ error: 'photoData array is required' });\n      }\n\n      const suggestions = await taskAI.processNewPhotos(user.id, photoData);\n\n      res.json({\n        success: true,\n        suggestionsCreated: suggestions.length,\n        suggestions,\n      });\n    } catch (error: unknown) {\n      console.error('Process photo GDPR error:', error);\n      res.status(500).json({ error: 'Failed to process photo data' });\n    }\n  });\n\n  app.get('/api/data-processing/jobs', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      const jobs = await storage.getDataProcessingJobsByUserId(user.id);\n      res.json(jobs);\n    } catch (error: unknown) {\n      console.error('Get data processing jobs error:', error);\n      res.status(500).json({ error: 'Failed to fetch data processing jobs' });\n    }\n  });\n\n  // Manual trigger for immediate AI analysis\n  app.post('/api/ai/trigger-analysis', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n      await taskScheduler.triggerImmediateAnalysis(user.id);\n\n      res.json({\n        success: true,\n        message: 'AI analysis triggered successfully. Check AI suggestions for results.',\n      });\n    } catch (error: unknown) {\n      console.error('Trigger AI analysis error:', error);\n      res.status(500).json({ error: 'Failed to trigger AI analysis' });\n    }\n  });\n\n  // Task analytics and insights\n  app.get('/api/tasks/analytics', requireAuth, async (req: Request, res: Response) => {\n    try {\n      if (!isAuthenticatedUser(req.user)) {\n        return res.status(401).json({ error: 'User not authenticated' });\n      }\n      const user = req.user;\n\n      const [allTasks, pendingTasks, completedTasks, aiTasks] = await Promise.all([\n        storage.getTasksByUserId(user.id),\n        storage.getTasksByUserId(user.id, ['pending']),\n        storage.getTasksByUserId(user.id, ['completed']),\n        storage.getTasksByStatus('in_progress', 'ai_assistant'),\n      ]);\n\n      const overdueTasks = allTasks.filter(\n        (task) => task.dueDate && new Date(task.dueDate) < new Date() && task.status !== 'completed'\n      );\n\n      const todaysTasks = allTasks.filter(\n        (task) =>\n          task.dueDate && new Date(task.dueDate).toDateString() === new Date().toDateString()\n      );\n\n      const analytics = {\n        totalTasks: allTasks.length,\n        pendingTasks: pendingTasks.length,\n        completedTasks: completedTasks.length,\n        overdueTasks: overdueTasks.length,\n        todaysTasks: todaysTasks.length,\n        aiTasksInProgress: aiTasks.length,\n        completionRate:\n          allTasks.length > 0 ? ((completedTasks.length / allTasks.length) * 100).toFixed(1) : '0',\n        averageCompletionTime: calculateAverageCompletionTime(completedTasks),\n      };\n\n      res.json(analytics);\n    } catch (error: unknown) {\n      console.error('Get task analytics error:', error);\n      res.status(500).json({ error: 'Failed to fetch task analytics' });\n    }\n  });\n\n  // Helper function for task analytics\n  interface CompletedTask {\n    completedAt?: Date | string | null;\n    createdAt?: Date | string | null;\n  }\n\n  function calculateAverageCompletionTime(completedTasks: CompletedTask[]): string {\n    if (completedTasks.length === 0) return '0 days';\n\n    const totalTime = completedTasks.reduce((sum, task) => {\n      if (task.completedAt && task.createdAt) {\n        const completedTime = new Date(task.completedAt).getTime();\n        const createdTime = new Date(task.createdAt).getTime();\n        return sum + (completedTime - createdTime);\n      }\n      return sum;\n    }, 0);\n\n    const avgMilliseconds = totalTime / completedTasks.length;\n    const avgDays = Math.round(avgMilliseconds / (1000 * 60 * 60 * 24));\n\n    return `${avgDays} days`;\n  }\n\n  const httpServer = createServer(app);\n  return httpServer;\n}\n","usedDeprecatedRules":[]}]